library(dplyr)
library(data.table)
library(tibble)
library(ComplexHeatmap)
library(EnrichedHeatmap)
library(circlize)
library(ggplot2)
require(doParallel)
library(amap)
library(imputeTS)
library(lazyeval)
library(ggplot2)
library(ggpubr)



##################################################################################
## colors for heatmap
colors_seq9 = data.frame(
  YlGnBu = c("#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"),
  YlOrRd = c("#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"),
  RdPu = c("#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"),
  OrRd = c("#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"),
  Reds = c("#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"),
  Oranges = c("#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"),
  PuBu = c("#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"),
  Blues = c("#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"),
  Purples = c("#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"),
  GnBu = c("#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"),
  stringsAsFactors = F
)


colors_qual = list(
  paired_12 = c("#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"),
  set1_9 = c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"),
  set3_12 = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f")
)







## function to impute NA values for the rows with NAs
naImpute = function(index, mat){
  xNew = na.mean(mat[index, ])
  return(xNew)
}

##################################################################################



##################################################################################
## get the profile matrix of class "normalizedMatrix"
getDeeptoolsProfileMatrix = function(file, signalName, selectGenes, up = 200, target = 200, down = 100){
  ## file:        profile matrix generated by deeptools (gzip compressed file)
  ## colNames:    vector of the column names
  ## signamName:  name to be used for this signal
  ## selectGenes: genes to consider. uORFs, mitochondiral genes are removed from this list. User may give a short list of his/her interest
  
  ## profile matrix column names
  header = c("chr", "start", "end", "geneID", "length", "strand", 
             paste(c("u"), 1:up, sep = ""), 
             paste(c("g"), 1:target, sep = ""), 
             paste(c("d"), 1:down, sep = "")
             )
  
  ## read the profile matrix which is in .gz file
  z1 = paste0("bash -c ", '"zcat ', file, '"', collapse = "")
  
  df = fread(z1, sep = "\t", header = F, skip = 1, na.strings = "nan", col.names = header, data.table = F) %>%
    dplyr::select(-c(chr, start, end, length, strand)) 
  
  
  profileDf = left_join(x = selectGenes, y = df, by = c("gene" = "geneID")) %>%
    column_to_rownames(var = "gene")
  
  
  profileMat = data.matrix(profileDf)
  
  ## find rows with NA values and ipmute the NA values: replace NA with mean(row)
  naRows = which(apply(profileMat, 1, function(x) any(is.na(x))))
  profileMat[naRows, ] = do.call(rbind, lapply(naRows, naImpute, mat = profileMat))
  
  ## compare the imputed values with non-imputed values
  # rowN = 13
  # plotNA.imputations(as.numeric(profileDf[naRows[rowN], ]), as.vector(profileMat[naRows[rowN], ]))
  
  ##set attributes for the profileMat to make it of class "normalizedMatrix"
  attr(profileMat, "upstream_index") = 1:up
  attr(profileMat, "target_is_single_point") = FALSE
  attr(profileMat, "target_index") = (up+1):(up+target)
  attr(profileMat, "downstream_index") = (up+target+1):(up+target+down)
  attr(profileMat, "extend") = c(up * 10, down * 10)
  attr(profileMat, "signal_name") = signalName
  attr(profileMat, "target_name") = "TSS"
  attr(profileMat, "empty_value") = "NA"
  
  class(profileMat) = c("normalizedMatrix", "matrix")
  
  
  # returns: profile matrix of class "normalizedMatrix"
  return(profileMat)
}

##################################################################################



##################################################################################
## get the profile matrix of class "normalizedMatrix" from Miao's profile matrix
getMiaoProfileMatrix = function(file, signalName, selectGenes, up = 200, target = 200, down = 100){
  ## file:        profile matrix generated by deeptools (gzip compressed file)
  ## colNames:    vector of the column names
  ## signamName:  name to be used for this signal
  ## selectGenes: genes to consider. uORFs, mitochondiral genes are removed from this list. User may give a short list of his/her interest
  
  
  ## profile matrix column names
  header = c("chr", "start", "end", "strand", "geneID", 
             paste(c("u"), 1:up, sep = ""), 
             paste(c("g"), 1:target, sep = ""), 
             paste(c("d"), 1:down, sep = "")
  )
  

  ## read the profile matrix which in in TAB delimited file
  df = fread(file, sep = "\t", header = F, na.strings = "NA", col.names = header, data.table = F) %>%
    select(-c(chr, start, end, strand))
  
  # print(head(df))

  profileDf = left_join(x = selectGenes, y = df, by = c("gene" = "geneID")) %>%
    column_to_rownames(var = "gene")

  profileMat = data.matrix(profileDf)

  ## find rows with NA values and ipmute the NA values: replace NA with mean(row)
  naRows = which(apply(profileMat, 1, function(x) any(is.na(x))))
  profileMat[naRows, ] = do.call(rbind, lapply(naRows, naImpute, mat = profileMat))

  ## compare the imputed values with non-imputed values
  # rowN = 13
  # plotNA.imputations(as.numeric(profileDf[naRows[rowN], ]), as.vector(profileMat[naRows[rowN], ]))

  ##set attributes for the profileMat to make it of class "normalizedMatrix"
  attr(profileMat, "upstream_index") = 1:up
  attr(profileMat, "target_is_single_point") = FALSE
  attr(profileMat, "target_index") = (up+1):(up+target)
  attr(profileMat, "downstream_index") = (up+target+1):(up+target+down)
  attr(profileMat, "extend") = c(up * 10, down * 10)
  attr(profileMat, "signal_name") = signalName
  attr(profileMat, "target_name") = "TSS"
  attr(profileMat, "empty_value") = "NA"

  class(profileMat) = c("normalizedMatrix", "matrix")


  # returns: profile matrix of class "normalizedMatrix"
  return(profileMat)
}



##################################################################################



##################################################################################
## main profile heatmap 
primaryProfileHeatmap = function(profileMat, signalName, numClust = 7, color, createClusters = TRUE, clusterStorePath){
  ## profileMat:        profile matrix
  ## signalName:        name of the signal
  ## numClust:          number of clusters for k-means clustering
  ## color:             color function generated by colorRamp2()
  ## createClusters:    whether to perform k-means clustering or not
  ## clusterStorePath:  path to store the k-means cluster data for current TF profile
  
  cat("Generating primary profile heatmap for sample", signalName, "\n")
  
  ## hirerchical clustering
  # dend = hclust(dist(profileMat), method = "ward.D")
  # clusterCut = cutree(dend, numClust)
  # clusterData = data.frame(gene = names(clusterCut), cluster = clusterCut, stringsAsFactors = F, row.names = names(clusterCut))
  
  if(missing(clusterStorePath)){
    stop("Error: Please provide the path to store/access cluster information")
  }
  
  
  clusterData = data.frame(gene = rownames(profileMat), cluster = NA, stringsAsFactors = F, row.names = rownames(profileMat))
  
  if(isTRUE(createClusters)){
    cat("Running k-means clustering for sample", signalName, "\nNumber of clusters:", numClust, "\n")
    
    ## perform k-means clustering
    km = kmeans(x = profileMat, centers = numClust, iter.max = 20, nstart = 100)
    clusterData[names(km$cluster), "cluster"] = km$cluster
    
    clusterData = mutate(clusterData, cluster = paste("Cluster_", cluster, sep = ""))
    
    ## store for future use
    write.table(x = clusterData, file = clusterStorePath, sep = "\t", col.names = T, quote = F, row.names = F)
    
  }
  else{
    cat("Reading k-means clustering information sample", signalName, "\nNumber of clusters:", numClust, "\n")
    
    ## read stored clustering information from file
    if(!file.exists(clusterStorePath)){
      stop("Error: Cluster file not found")
    }
    
    clusterData = fread(file = clusterStorePath, sep = "\t", header = T, stringsAsFactors = F, data.table = F)
    
  }
  
  cat("Done...\n")
  
  row.names(clusterData) = clusterData$gene
  
  # set colors for clusters. IMP to sort as they will be arranged on heatmap in order
  div9_col = c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#a65628", "#f781bf", "#999999", "#ffff33")
  # print(unique(clusterData$cluster))
  
  clusterNames = sort(unique(clusterData$cluster))
  clusterColor = structure(div9_col[1:length(clusterNames)], names = clusterNames)
  
  ## annotation legend
  lgd = Legend(at = names(clusterColor), title = "Clusters", 
               type = "lines", legend_gp = gpar(col = clusterColor))
  
  ## generate profile heatmap
  ht = EnrichedHeatmap(
    profileMat, col = color,
    name = signalName, axis_name_rot = 90,
    column_title = signalName,
    split = clusterData["cluster"],
    top_annotation = HeatmapAnnotation(lines = anno_enriched(gp = gpar(col = clusterColor), 
                                                             show_error = T
                                                             # ylim = c(0, quantile(profileMat, 0.999))
                                                             )
                                       ),
    top_annotation_height = unit(2, "cm"),
    row_title_rot = 0
  )
  
  ## generate row annotation of clusters
  htAnno = rowAnnotation(df = clusterData["cluster"],
                         col = list(cluster = clusterColor),
                         width = unit(0.5, "cm"),
                         show_legend = F
  )
  
  cat("Done!!!\n")
  
  ##returns: profile heatmap, annotation legend, clusterData
  return(list(
    "heatmap" = ht,
    "rowAnno" = htAnno,
    "legend" = lgd, 
    "cluster" = clusterData,
    "clusterColor" = clusterColor,
    "profileColor" = color
  ))
}

##################################################################################



##################################################################################
## secondary profile heatmap

secondaryProfileHeatmap = function(profileMat, signalName, clusterData, heatmapColor, clusterColor){
  ## profileMat:    
  ## signalName:    
  ## clusterData:   
  ## heatmapColor:  
  ## clusterColor:  
  
  cat("Generating secondary profile heatmap for sample", signalName, "\n")
  
  ## annotation legend
  lgd = Legend(at = names(clusterColor), title = "Clusters", 
               type = "lines", legend_gp = gpar(col = clusterColor))
  
  ## modify the clusterColor: remove the cluster_x which is not present in the clusterData
  clusterColor = clusterColor[sort(unique(clusterData$cluster))]
  
  # print(clusterColor)
  
  ## generate profile heatmap
  ht = EnrichedHeatmap(
    profileMat, col = heatmapColor,
    name = signalName, axis_name_rot = 90,
    column_title = signalName,
    split = clusterData["cluster"],
    top_annotation = HeatmapAnnotation(lines = anno_enriched(gp = gpar(col = clusterColor), 
                                                             show_error = T
                                                             # ylim = c(0, quantile(profileMat, 0.995))
                                                             )
                                       ),
    top_annotation_height = unit(2, "cm"),
    row_title_rot = 0
  )
  
  ## generate row annotation of clusters
  htAnno = rowAnnotation(df = clusterData["cluster"],
                         col = list(cluster = clusterColor),
                         width = unit(0.5, "cm"),
                         show_legend = F
  )
  
  cat("Done!!!\n")
  
  ##returns: profile heatmap, annotation legend, clusterData
  return(list(
    "heatmap" = ht,
    "rowAnno" = htAnno,
    "legend" = lgd,
    "profileColor" = heatmapColor
  ))
}

##################################################################################



##################################################################################
## read polII expression data
get_secondary_polII_data = function(file, title, clusterData){
  ## file:        pol-II FPKM file generated by Miao's script
  ## title:       pol-II sample name to be used as column name
  ## clusterData: gene cluster data frame. pol-II values column will be joined to this DF
  
  
  polII_df = fread(input = file, header = F, drop = c(1,2,3,5,6), col.names = c("geneID", title),  stringsAsFactors = F, sep = "\t", data.table = F) 
  
  
  clusterData = clusterData %>% left_join(y = polII_df, by = c("gene" = "geneID"))
  
  polII_df = clusterData %>%
    select(gene, !!(as.name(title))) %>%
    column_to_rownames(var = "gene")
  
  polII_mat = data.matrix(polII_df)
  
  polII_log2_mat = log2(polII_mat + 1)
  
  polII_q = quantile(polII_log2_mat, c(seq(0, 0.9, by = 0.1), 0.95, 0.99, 0.992, 0.995, 0.999, 1), na.rm = T)
  print(paste("Quantiles for polII data", file, sep = ": "), quote = F)
  print(polII_q)
  
  # return: log2(polII expression) matrix, clusterData
  return(list(
    "log2_mat" = polII_log2_mat,
    "clusterDf" = clusterData,
    "quantiles" = polII_q
  ))
}

##################################################################################



##################################################################################
## get the top 10% genes as expressed genes from polII data
get_expressed_polII_genes = function(df, n, field){
  # this function uses interp() from lazyeval package to interpret the dynamic column name for dplyr function top_n()
  topFraction <- round(nrow(df) * n / 100)
  
  # call = quote(df %>%
  #                 top_n(topFraction, wt = .wt))
  # call = interp(call, .wt = as.name(field))
  # newDf = eval(call)
  
  newDf = df %>% top_n(topFraction, !! as.name(field))
  
  return(newDf)
  
}
##################################################################################



##################################################################################
## generate complexHeatmap of single polII data
polII_heatmap_secondary = function(log2_matrix, col_title, legend_title, color, htSplit = NULL, showLegend = TRUE){
  
  cat("Generating expression heatmap for sample", col_title, "\n")
  
  ## column name annotation for allele_ht Heatmap
  colNameAnn <- HeatmapAnnotation(colName = anno_text(x = c(col_title),
                                                      rot = 90, just = "left",
                                                      offset = unit(1, "mm"))
                                  )
  
  ## draw heatmap
  ht = Heatmap(log2_matrix, name = col_title,
               col = color,
               top_annotation = colNameAnn,
               top_annotation_height = unit.c(unit(5, "mm"), max_text_width(col_title) + unit(2, "mm")),
               show_row_names = FALSE, show_column_names = FALSE,
               width = unit(1, "cm"),
               show_heatmap_legend = showLegend,
               heatmap_legend_param = list(title = legend_title, 
                                           legend_height = unit(3, "cm"),
                                           at = seq(0, max(log2_matrix), by = 2),
                                           color_bar = "continuous"),
               split = htSplit
               )
  
  cat("Done!!!\n")
  
  return(ht)
}

##################################################################################



##################################################################################
## add SM_gene information to the expression profile clusterData
add_SM_cluster_info = function(file, clusterDf){
  smData = fread(input = file, header = T, drop = c(2,3,4,5,6,7),  stringsAsFactors = F, sep = "\t", data.table = F)
  smData$is_SM_gene = TRUE
  
  clusterDf = clusterDf %>%
    left_join(y = smData, by = c("gene" = "SM_gene"))
  
  return(clusterDf)
}

##################################################################################



##################################################################################
## add different gene class types annotation: eg. TF, SM_gene etc
add_gene_info = function(file, clusterDf){
  geneData = fread(input = file, header = T, drop = c(2,3),  stringsAsFactors = F, sep = "\t", data.table = F)

  clusterDf = clusterDf %>%
    left_join(y = geneData, by = c("gene" = "gene"))
  
  return(clusterDf)
}

##################################################################################



##################################################################################
add_top10_expressed_anno = function(expressedDf, clusterDf, name, polIIExpFile){
 
  isExpCol = paste0("is_expressed(", name, ")", collapse = "")
  expressedDf[isExpCol] = TRUE
  
  expressedDf = expressedDf %>% select(gene, starts_with("is_expressed"))
  
  clusterDf = clusterDf %>%
    left_join(y = expressedDf, by = c("gene" = "gene")) %>%
    mutate(!!isExpCol := ifelse(is.na(!! as.name(isExpCol)), FALSE, !! as.name(isExpCol)))
  
  ## save the polII data for future use
  saveDf = clusterDf  %>% select(gene, contains(!! name))
  write.table(x = saveDf, file = polIIExpFile, sep = "\t", col.names = T, quote = F, row.names = F)
  
  cat("Added top 10% expressed information...\n")
  
  return(clusterDf)
  
}

##################################################################################



##################################################################################
## add MACS2 peak calling results to expression profile clusterData
add_macs2Peak_info = function(macs2Out, peakAnnoFile, peakType, clusterDf, duplicate_select, peakCol){
  ## macs2Out, peakAnnoFile, peakType, clusterDf, duplicate_select, peakCol
  ## macs2Out: narrowpeak or broadpeak output file by MACS2
  ## peakAnnoFile: summits.bed or center.bed file annotated with closest gene
  ## peakType: narrow/broad
  ## clusterDf: cluster data
  ## duplicate_select: "min" OR "max". In case of multiple peaks near single gene, this value tell how to select only one.
  ## IMP: since bedtools closest was run with distance w.r.t. "b", we have -ve values for the peak which is near TSS. In this case the closest should be determined by "max"
  ## peakCol: is_TSS_peak
  
  peakCols = c("peakChr", "peakStart", "peakEnd", "peakId", "peakScore", "peak_strand", "peak_enrichment", "peak_pVal", "peak_qVal")
  
  df = fread(input = macs2Out, header = F, select = c(1:9),  
             stringsAsFactors = F, sep = "\t", data.table = F, na.strings = "NA",
             col.names = peakCols)
  
  peakAnnDf = fread(file = peakAnnoFile, header = F, select = c(2, 4, 9, 12),
                stringsAsFactors = F, sep = "\t", data.table = F,
                col.names = c("peak_summit", "peakId", "peak_gene", "peak_dist"))
  
  peakAnnDf[peakCol] = TRUE
  
  peakAnnDf = left_join(x = peakAnnDf, y = df, by = c("peakId" = "peakId")) %>% 
    select(!! peakCol, peakChr, peakStart, peakEnd, peakId, peak_enrichment, peak_pVal, peak_qVal, peak_gene, peak_dist, peak_summit)
  
  
  ## select the specific columns from peak data and 
  ## if the gene has multiple rows, select the peak which has least distance to the row
  if(duplicate_select == "max"){
   
    peakAnnDf = peakAnnDf %>% 
      group_by(peak_gene) %>%
      dplyr::slice(which.max(peak_dist)) %>% 
      ungroup()
    
  }
  else if(duplicate_select == "min"){
    
    peakAnnDf = peakAnnDf %>% 
      group_by(peak_gene) %>%
      dplyr::slice(which.min(peak_dist)) %>% 
      ungroup()
    
  }
  else{
    stop("Error: Cannot determine which row to select when duplicate gene rows are found")
  }
  
  
  clusterDf = clusterDf %>%
    left_join(y = peakAnnDf, by = c("gene" = "peak_gene"))  %>%
    mutate(!! peakCol := ifelse(is.na(!! as.name(peakCol)), FALSE, !!as.name(peakCol) ) )
  
  cat("Added TF binding information...\n")
  
  return(clusterDf)
  
}

##################################################################################





